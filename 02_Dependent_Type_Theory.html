<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-02-02 Thu 16:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Theorem Proving in Lean</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://leodemoura.github.io][Leonardo de Moura]]Leonardo de Moura, [[http://www.cs.cmu.edu/~soonhok][Soonho Kong]]Soonho Kong" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-orge7a4a04" class="outline-2">
<h2 id="Dependent_Type_Theory"><a id="orge7a4a04"></a><span class="section-number-2"> 2</span> Dependent Type Theory</h2>
<div class="outline-text-2" id="text-Dependent_Type_Theory">
<p>
Dependent type theory is a powerful and expressive language, allowing
us to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way. Lean is based on a version of dependent type
theory known as the <i>Calculus of Inductive Constructions</i>, with a
countable hierarchy of non-cumulative universes and inductive
types. By the end of this chapter, you will understand much of what
this means.
</p>
</div>

<div id="outline-container-org41ddcbf" class="outline-3">
<h3 id="org41ddcbf"><span class="section-number-3"> 2.1</span> Simple Type Theory</h3>
<div class="outline-text-3" id="text-1-1">
<p>
As a foundation for mathematics, set theory has a simple ontology that
is rather appealing. Everything is a set, including numbers,
functions, triangles, stochastic processes, and Riemannian
manifolds. It is a remarkable fact that one can construct a rich
mathematical universe from a small number of axioms that describe a
few basic set-theoretic constructions.
</p>

<p>
But for many purposes, including formal theorem proving, it is better
to have an infrastructure that helps us manage and keep track of the
various kinds of mathematical objects we are working with. "Type
theory" gets its name from the fact that every expression has an
associated <i>type</i>. For example, in a given context, <code>x + 0</code> may
denote a natural number and <code>f</code> may denote a function on the natural
numbers.
</p>

<p>
Here are some examples of how we can declare objects in Lean and
check their types.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">/- declare some constants -/

constant m : nat        -- m is a natural number
constant n : nat
constants b1 b2 : bool  -- declare two constants at once

/- check their types -/

check m            -- output: nat
check n
check n + 0        -- nat
check m * (n + 0)  -- nat
check b1           -- bool
check b1 &amp;&amp; b2     -- "&amp;&amp;" is boolean and
check b1 || b2     -- boolean or
check tt           -- boolean "true"

-- Try some examples of your own.
</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>/- declare some constants -/

constant m : nat        -- m is a natural number
constant n : nat
constants b1 b2 : bool  -- declare two constants at once

/- check their types -/

check m            -- output: nat
check n
check n + 0        -- nat
check m * (n + 0)  -- nat
check b1           -- bool
check b1 &amp;&amp; b2     -- "&amp;&amp;" is boolean and
check b1 || b2     -- boolean or
check tt           -- boolean "true"

-- Try some examples of your own.
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The <code>/-</code> and <code>-/</code> annotations indicate that the next line is a comment
block that is ignored by Lean. Similarly, two dashes indicate that the
rest of the line contains a comment that is also ignored. Comment
blocks can be nested, making it possible to "comment out" chunks of
code, just as in many programming languages.
</p>

<p>
The <code>constant</code> and <code>constants</code> commands introduce new constant symbols
into the working environment, and the <code>check</code> command asks Lean to
report their types. You should test this, and try typing some examples
of your own. Declaring new objects in this way is a good way to
experiment with the system, but it is ultimately undesirable: Lean is
a foundational system, which is to say, it provides us with powerful
mechanisms to <i>define</i> all the mathematical objects we need, rather
than simply postulating them to the system. We will explore these
mechanisms in the chapters to come.
</p>

<p>
What makes simple type theory powerful is that one can build new types
out of others. For example, if <code>α</code> and <code>β</code> are types, <code>α → β</code> denotes
the type of functions from <code>α</code> to <code>β</code>, and <code>α × β</code> denotes the cartesian
product, that is, the type of ordered pairs consisting of an element
of <code>α</code> paired with an element of <code>β</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">constants m n : nat

constant f : nat → nat           -- type the arrow as "\to" or "\r"
constant f' : nat -&gt; nat         -- alternative ASCII notation
constant f'' : ℕ → ℕ             -- \nat is alternative notation for nat
constant p : nat × nat           -- type the product as "\times"
constant q : prod nat nat        -- alternative notation
constant g : nat → nat → nat
constant g' : nat → (nat → nat)  -- has the same type as g!
constant h : nat × nat → nat

constant F : (nat → nat) → nat   -- a "functional"

check f               -- ℕ → ℕ
check f n             -- ℕ
check g m n           -- ℕ
check g m             -- ℕ → ℕ
check (m, n)          -- ℕ × ℕ
check p.1             -- ℕ
check p.2             -- ℕ
check (m, n).1        -- ℕ
check (p.1, n)        -- ℕ × ℕ
check F f             -- ℕ

-- Try it on your own: write down some types, declare some constants,
-- and check some expressions.
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>constants m n : nat

constant f : nat → nat           -- type the arrow as "\to" or "\r"
constant f' : nat -&gt; nat         -- alternative ASCII notation
constant f'' : ℕ → ℕ             -- \nat is alternative notation for nat
constant p : nat × nat           -- type the product as "\times"
constant q : prod nat nat        -- alternative notation
constant g : nat → nat → nat
constant g' : nat → (nat → nat)  -- has the same type as g!
constant h : nat × nat → nat

constant F : (nat → nat) → nat   -- a "functional"

check f               -- ℕ → ℕ
check f n             -- ℕ
check g m n           -- ℕ
check g m             -- ℕ → ℕ
check (m, n)          -- ℕ × ℕ
check p.1             -- ℕ
check p.2             -- ℕ
check (m, n).1        -- ℕ
check (p.1, n)        -- ℕ × ℕ
check F f             -- ℕ

-- Try it on your own: write down some types, declare some constants,
-- and check some expressions.
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Let us dispense with some basic syntax. You can enter the unicode
arrow <code>→</code> by typing <code>\to</code> or "<code>\r</code>. You can also use the ASCII
alternative <code>-&gt;</code>, so that the expression <code>nat -&gt; nat</code> and <code>nat → nat</code>
mean the same thing. Both expressions denote the type of functions
that take a natural number as input and return a natural number as
output. The symbol <code>ℕ</code> is alternative unicode notation for <code>nat</code>; you
can enter it by typing <code>\nat</code>. The unicode symbol <code>×</code> for the
cartesian product is entered <code>\times</code>. We will generally use lower-case
greek letters like <code>α</code>, <code>β</code>, and <code>γ</code> to range over types. You can
enter these particular ones with <code>\a</code>, <code>\b</code>, and <code>\g</code>.
</p>

<p>
There are a few more things to notice here. First, the
application of a function <code>f</code> to a value <code>x</code> is denoted <code>f x</code>. Second,
when writing type expressions, arrows associate to the <i>right</i>; for
example, the type of <code>g</code> is <code>nat → (nat → nat)</code>. Thus we can view <code>g</code>
as a function that takes natural numbers and returns another function
that takes a natural number and returns a natural number. In type
theory, this is generally more convenient than writing <code>g</code> as a
function that takes a pair of natural numbers as input, and returns a
natural number as output. For example, it allows us to "partially
apply" the function <code>g</code>. The example above shows that <code>g m</code> has type
<code>nat → nat</code>, that is, the function that "waits" for a second argument,
<code>n</code>, and then returns <code>g m n</code>. Taking a function <code>h</code> of type <code>nat ×
nat → nat</code> and "redefining" it to look like <code>g</code> is a process known as
<i>currying</i>, something we will come back to below.
</p>

<p>
By now you may also have guessed that, in Lean, <code>(m, n)</code> denotes the
ordered pair of <code>m</code> and <code>n</code>, and if <code>p</code> is a pair, <code>fst p</code> and <code>snd p</code>
denote the two projections.
</p>
</div>
</div>

<div id="outline-container-orge8ac323" class="outline-3">
<h3 id="orge8ac323"><span class="section-number-3"> 2.2</span> Types as Objects</h3>
<div class="outline-text-3" id="text-1-2">
<p>
One way in which Lean's dependent type theory extends simple type
theory is that types themselves &#x2013; entities like <code>nat</code> and <code>bool</code> &#x2013;
are first-class citizens, which is to say that they themselves are
objects of study. For that to be the case, each of them also has to
have a type.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">check nat               -- Type
check bool              -- Type
check nat → bool        -- Type
check nat × bool        -- Type
check nat → nat         -- ...
check nat × nat → nat
check nat → nat → nat
check nat → (nat → nat)
check nat → nat → bool
check (nat → nat) → nat
</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>check nat               -- Type
check bool              -- Type
check nat → bool        -- Type
check nat × bool        -- Type
check nat → nat         -- ...
check nat × nat → nat
check nat → nat → nat
check nat → (nat → nat)
check nat → nat → bool
check (nat → nat) → nat
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>

<p>
We see that each one of the expressions above is an object of type
<code>Type</code>.  We can also declare new constants and constructors for types:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">constants α β : Type
constant F : Type → Type
constant G : Type → Type → Type

check α        -- Type
check F α      -- Type
check F nat    -- Type
check G α      -- Type → Type
check G α β    -- Type
check G α nat  -- Type
</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>constants α β : Type
constant F : Type → Type
constant G : Type → Type → Type

check α        -- Type
check F α      -- Type
check F nat    -- Type
check G α      -- Type → Type
check G α β    -- Type
check G α nat  -- Type
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Indeed, we have already seen an example of a function of type <code>Type →
Type → Type</code>, namely, the Cartesian product.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">constants α β : Type

check prod α β       -- Type
check prod nat nat   -- Type
</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>constants α β : Type

check prod α β       -- Type
check prod nat nat   -- Type
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here is another example: given any type <code>α</code>, the type <code>list α</code> denotes
the type of lists of elements of type <code>α</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">constant α : Type

check list α    -- Type
check list nat  -- Type
</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>constant α : Type

check list α    -- Type
check list nat  -- Type
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>

<p>
For those more comfortable with set-theoretic foundations, it may be
helpful to think of a type as nothing more than a set, in which case,
the elements of the type are just the elements of the set. Given that
every expression in Lean has a type, it is natural to ask: what type
does <code>Type</code> itself have?
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">check Type      -- Type₂
</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>check Type      -- Type₂
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We have actually come up against one of the most subtle aspects of
Lean's typing system. Lean's underlying foundation has an infinite
hierarchy of types:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">check Type 1   -- Type₂
check Type 2   -- Type₃
check Type 3   -- Type 4
check Type 4   -- Type 5
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>check Type 1   -- Type₂
check Type 2   -- Type₃
check Type 3   -- Type 4
check Type 4   -- Type 5
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Think of <code>Type 1</code> as a universe of "small" or "ordinary" types.
<code>Type 2</code> is then a larger universe of types, which contains <code>Type 1</code> as an
element, and <code>Type 3</code> is an even larger universe of types, which
contains <code>Type 2</code> as an element. The list is indefinite, so that there
is a <code>Type n</code> for every natural number <code>n</code>. Lean introduces
abbreviations for the first three levels:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">check Type    -- same as Type 1
check Type₂   -- same as Type 2
check Type₃   -- same as Type 3
</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>check Type    -- same as Type 1
check Type₂   -- same as Type 2
check Type₃   -- same as Type 3
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It is rare to have to use more than those. There is also a <code>Type 0</code>,
which is also denoted <code>Prop</code>. This type has special properties, and
will be discussed in the next chapter.
</p>

<p>
We want some operations, however, to be <i>polymorphic</i> over type
universes. For example, <code>list α</code> should make sense for any type <code>α</code>,
no matter which type universe <code>α</code> lives in. This explains the type
annotation of the function <code>list</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">check list    -- Type u_1 → Type (max 1 u_1)
</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>check list    -- Type u_1 → Type (max 1 u_1)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here <code>u_1</code> is a variable ranging over type levels. The output of the
<code>check</code> command means that whenever <code>α</code> has type <code>Type n</code>, <code>list α</code>
also has type <code>Type n</code> if <code>n</code> is at least 1, and has <code>Type 1</code> if <code>α</code>
has type <code>0</code>. The function <code>prod</code> is similarly polymorphic:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">check prod    -- Type u_1 → Type u_2 → Type (max 1 u_1 u_2)
</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>check prod    -- Type u_1 → Type u_2 → Type (max 1 u_1 u_2)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
To define polymorphic constants and variables, Lean allows us to
declare universe variables explicitly:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">universe variable u
constant α : Type u
check α
</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>universe variable u
constant α : Type u
check α
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Throughout this book, you will see us do this in examples when we want
type constructions to have as much generality as possible. We will see
that the ability to treat type constructors as instances of ordinary
mathematical functions is a powerful feature of dependent type theory.
</p>
</div>
</div>

<div id="outline-container-orgd88710b" class="outline-3">
<h3 id="orgd88710b"><span class="section-number-3"> 2.3</span> Function Abstraction and Evaluation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
We have seen that if we have <code>m n : nat</code>, then we have <code>(m, n) : nat
× nat</code>. This gives us a way of creating pairs of natural numbers.
Conversely, if we have <code>p : nat × nat</code>, then we have <code>fst p : nat</code> and
<code>snd p : nat</code>. This gives us a way of "using" a pair, by extracting its
two components.
</p>

<p>
We already know how to "use" a function <code>f : α → β</code>, namely, we can
apply it to an element <code>a : α</code> to obtain <code>f a : β</code>. But how do we
create a function from another expression?
</p>

<p>
The companion to application is a process known as "abstraction," or
"lambda abstraction." Suppose that by temporarily postulating a
variable <code>x : α</code> we can construct an expression <code>t : β</code>. Then the
expression <code>fun x : α, t</code>, or, equivalently, <code>λ x : α, t</code>, is an object
of type <code>α → β</code>. Think of this as the function from <code>α</code> to <code>β</code> which
maps any value <code>x</code> to the value <code>t</code>, which depends on <code>x</code>. For
example, in mathematics it is common to say "let <code>f</code> be the function
which maps any natural number <code>x</code> to <code>x + 5</code>." The expression <code>λ x :
nat, x + 5</code> is just a symbolic representation of the right-hand side
of this assignment.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">check fun x : nat, x + 5
check λ x : nat, x + 5
</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>check fun x : nat, x + 5
check λ x : nat, x + 5
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here are some more abstract examples:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">constants α β  : Type
constants a1 a2 : α
constants b1 b2 : β

constant f : α → α
constant g : α → β
constant h : α → β → α
constant p : α → α → bool

check fun x : α, f x                      -- α → α
check λ x : α, f x                        -- α → α
check λ x : α, f (f x)                    -- α → α
check λ x : α, h x b1                     -- α → α
check λ y : β, h a1 y                     -- β → α
check λ x : α, p (f (f x)) (h (f a1) b2)  -- α → bool
check λ x : α, λ y : β, h (f x) y         -- α → β → α
check λ (x : α) (y : β), h (f x) y        -- α → β → α
check λ x y, h (f x) y                    -- α → β → α
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>constants α β  : Type
constants a1 a2 : α
constants b1 b2 : β

constant f : α → α
constant g : α → β
constant h : α → β → α
constant p : α → α → bool

check fun x : α, f x                      -- α → α
check λ x : α, f x                        -- α → α
check λ x : α, f (f x)                    -- α → α
check λ x : α, h x b1                     -- α → α
check λ y : β, h a1 y                     -- β → α
check λ x : α, p (f (f x)) (h (f a1) b2)  -- α → bool
check λ x : α, λ y : β, h (f x) y         -- α → β → α
check λ (x : α) (y : β), h (f x) y        -- α → β → α
check λ x y, h (f x) y                    -- α → β → α
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of <code>x</code> and <code>y</code> from the
types of <code>f</code> and <code>h</code>.
</p>

<p>
Be sure to try writing some expressions of your own. Some
mathematically common examples of operations of functions can be
described in terms of lambda abstraction:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">constants α β γ : Type
constant f : α → β
constant g : β → γ
constant b : β

check λ x : α, x        -- α → α
check λ x : α, b        -- α → β
check λ x : α, g (f x)  -- α → γ
check λ x, g (f x)

-- we can abstract any of the constants in the previous definitions

check λ b : β, λ x : α, x     -- β → α → α
check λ (b : β) (x : α), x    -- equivalent to the previous line
check λ (g : β → γ) (f : α → β) (x : α), g (f x)
                              -- (β → γ) → (α → β) → α → γ
-- we can even abstract over the type

check λ (α β : Type) (b : β) (x : α), x
check λ (α β γ : Type) (g : β → γ) (f : α → β) (x : α), g (f x)
</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>constants α β γ : Type
constant f : α → β
constant g : β → γ
constant b : β

check λ x : α, x        -- α → α
check λ x : α, b        -- α → β
check λ x : α, g (f x)  -- α → γ
check λ x, g (f x)

-- we can abstract any of the constants in the previous definitions

check λ b : β, λ x : α, x     -- β → α → α
check λ (b : β) (x : α), x    -- equivalent to the previous line
check λ (g : β → γ) (f : α → β) (x : α), g (f x)
                              -- (β → γ) → (α → β) → α → γ
-- we can even abstract over the type

check λ (α β : Type) (b : β) (x : α), x
check λ (α β γ : Type) (g : β → γ) (f : α → β) (x : α), g (f x)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Think about what these expressions mean. The expression <code>λ x : α, x</code>
denotes the identity function on <code>α</code>, the expression <code>λ x : α, b</code>
denotes the constant function that always returns <code>b</code>, and <code>λ x : α, g
(f x)</code>, denotes the composition of <code>f</code> and <code>g</code>. We can, in general,
leave off the type annotations on the variable and let Lean infer it
for us. So, for example, we can write <code>λ x, g (f x)</code> instead of <code>λ x :
α, g (f x)</code>.
</p>

<p>
We can abstract over any of the constants in the previous definitions:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">check λ b : β, λ x : α, x     -- β → α → α
check λ (b : β) (x : α), x    -- β → α → α
check λ (g : β → γ) (f : α → β) (x : α), g (f x)
                              -- (β → γ) → (α → β) → α → γ</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>constants α β γ : Type
constant f : α → β
constant g : β → γ
constant b : β

check λ b : β, λ x : α, x     -- β → α → α
check λ (b : β) (x : α), x    -- β → α → α
check λ (g : β → γ) (f : α → β) (x : α), g (f x)
                              -- (β → γ) → (α → β) → α → γ

check λ (α β : Type) (b : β) (x : α), x
check λ (α β γ : Type) (g : β → γ) (f : α → β) (x : α), g (f x)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Lean lets us combine lambdas, so the second example is equivalent to
the first. We can even abstract over the type:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">check λ (α β : Type) (b : β) (x : α), x
check λ (α β γ : Type) (g : β → γ) (f : α → β) (x : α), g (f x)</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>constants α β γ : Type
constant f : α → β
constant g : β → γ
constant b : β

check λ (α β : Type) (b : β) (x : α), x
check λ (α β γ : Type) (g : β → γ) (f : α → β) (x : α), g (f x)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The last expression, for example, denotes the function that takes
three types, <code>α</code>, <code>β</code>, and <code>γ</code>, and two functions, <code>g : β → γ</code> and
<code>f : α → β</code>, and returns the composition of <code>g</code> and <code>f</code>. (Making sense
of the type of this function requires an understanding of dependent
products, which we will explain below.) Within a lambda expression <code>λ
x : α, t</code>, the variable <code>x</code> is a "bound variable": it is really a
placeholder, whose "scope" does not extend beyond <code>t</code>. For example,
the variable <code>b</code> in the expression <code>λ (b : β) (x : α), x</code> has nothing
to do with the constant <code>b</code> declared earlier. In fact, the expression
denotes the same function as <code>λ (u : β) (z : α), z</code>. Formally, the
expressions that are the same up to a renaming of bound variables are
called <i>alpha equivalent</i>, and are considered "the same." Lean
recognizes this equivalence.
</p>

<p>
Notice that applying a term <code>t : α → β</code> to a term <code>s : α</code> yields an
expression <code>t s : β</code>. Returning to the previous example and renaming
bound variables for clarity, notice the types of the following
expressions:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">constants α β γ : Type
constant f : α → β
constant g : β → γ
constant h : α → α
constants (a : α) (b : β)

check (λ x : α, x) a                -- α
check (λ x : α, b) a                -- β
check (λ x : α, b) (h a)            -- β
check (λ x : α, g (f x)) (h (h a))  -- γ

check (λ (v : β → γ) (u : α → β) x, v (u x)) g f a   -- γ

check (λ (Q R S : Type) (v : R → S) (u : Q → R) (x : Q),
        v (u x)) α β γ g f a        -- γ
</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>constants α β γ : Type
constant f : α → β
constant g : β → γ
constant h : α → α
constants (a : α) (b : β)

check (λ x : α, x) a                -- α
check (λ x : α, b) a                -- β
check (λ x : α, b) (h a)            -- β
check (λ x : α, g (f x)) (h (h a))  -- γ

check (λ (v : β → γ) (u : α → β) x, v (u x)) g f a   -- γ

check (λ (Q R S : Type) (v : R → S) (u : Q → R) (x : Q),
        v (u x)) α β γ g f a        -- γ
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>
<p>
As expected, the expression <code>(λ x : α, x) a</code> has type <code>α</code>. In fact,
more should be true: applying the expression <code>(λ x : α, x)</code> to <code>a</code>
should "return" the value <code>a</code>. And, indeed, it does:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">constants α β γ : Type
constant f : α → β
constant g : β → γ
constant h : α → α
constants (a : α) (b : β)

eval (λ x : α, x) a                -- a
eval (λ x : α, b) a                -- b
eval (λ x : α, b) (h a)            -- b
eval (λ x : α, g (f x)) a          -- g (f a)

eval (λ (v : β → γ) (u : α → β) x, v (u x)) g f a   -- g (f a)

eval (λ (Q R S : Type) (v : R → S) (u : Q → R) (x : Q),
       v (u x)) α β γ g f a        -- g (f a)
</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>constants α β γ : Type
constant f : α → β
constant g : β → γ
constant h : α → α
constants (a : α) (b : β)

eval (λ x : α, x) a                -- a
eval (λ x : α, b) a                -- b
eval (λ x : α, b) (h a)            -- b
eval (λ x : α, g (f x)) a          -- g (f a)

eval (λ (v : β → γ) (u : α → β) x, v (u x)) g f a   -- g (f a)

eval (λ (Q R S : Type) (v : R → S) (u : Q → R) (x : Q),
       v (u x)) α β γ g f a        -- g (f a)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The command <code>eval</code> tells Lean to <i>evaluate</i> an expression. The process
of simplifying an expression <code>(λ x, t)s</code> to <code>t[s/x]</code> &#x2013; that is, <code>t</code>
with <code>s</code> substituted for the variable <code>x</code> &#x2013; is known as <i>beta
reduction</i>, and two terms that beta reduce to a common term are called
<i>beta equivalent</i>. But the <code>eval</code> command carries out other forms of
reduction as well:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">constants m n : nat
constant b : bool

print "reducing pairs"
eval (m, n).1        -- m
eval (m, n).2        -- n

print "reducing boolean expressions"
eval tt &amp;&amp; ff        -- ff
eval b &amp;&amp; ff         -- ff

print "reducing arithmetic expressions"
eval n + 0           -- n
eval n + 2           -- succ (succ n)
eval 2 + 3           -- 5
</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>constants m n : nat
constant b : bool

print "reducing pairs"
eval (m, n).1        -- m
eval (m, n).2        -- n

print "reducing boolean expressions"
eval tt &amp;&amp; ff        -- ff
eval b &amp;&amp; ff         -- ff

print "reducing arithmetic expressions"
eval n + 0           -- n
eval n + 2           -- succ (succ n)
eval 2 + 3           -- 5
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In a later chapter, we will explain how these terms are evaluated. For
now, we only wish to emphasize that this is an important feature of
dependent type theory: every term has a computational behavior, and
supports a notion of reduction, or <i>normalization</i>. In principle, two
terms that reduce to the same value are called <i>definitionally
equal</i>. They are considered "the same" by the underlying logical
framework, and Lean does its best to recognize and support these
identifications.
</p>
</div>
</div>

<div id="outline-container-orgd7847f6" class="outline-3">
<h3 id="orgd7847f6"><span class="section-number-3"> 2.4</span> Introducing Definitions</h3>
<div class="outline-text-3" id="text-1-4">
<p>
As we have noted above, declaring constants in the Lean environment is
a good way to postulate new objects to experiment with, but most of
the time what we really want to do is <i>define</i> objects in Lean
and prove things about them. The <code>definition</code> command provides one
important way of defining new objects.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">definition foo : (ℕ → ℕ) → ℕ := λ f, f 0

check foo    -- ℕ
print foo    -- λ (f : ℕ → ℕ), f 0
</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>definition foo : (ℕ → ℕ) → ℕ := λ f, f 0

check foo    -- ℕ
print foo    -- λ (f : ℕ → ℕ), f 0
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-21').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can omit the type when Lean has enough information to infer it:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">definition foo' := λ f : ℕ → ℕ, f 0
</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>definition foo' := λ f : ℕ → ℕ, f 0
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The general form of a definition is <code>definition foo : T := bar</code>. Lean
can usually infer the type <code>T</code>, but it is often a good idea to write
it explicitly. This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have the right
type.
</p>

<p>
Because function definitions are so common, Lean provides the shorthand
<code>def</code> for <code>definition</code>, and an alternative notation, which puts the abstracted variables before the
colon and omits the lambda:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">def double (x : ℕ) : ℕ := x + x
print double
check double 3
eval double 3    -- 6

def square (x : ℕ) := x * x
print square
check square 3
eval square 3    -- 9

def do_twice (f : ℕ → ℕ) (x : ℕ) : ℕ := f (f x)

eval do_twice double 2    -- 8
</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>def double (x : ℕ) : ℕ := x + x
print double
check double 3
eval double 3    -- 6

def square (x : ℕ) := x * x
print square
check square 3
eval square 3    -- 9

def do_twice (f : ℕ → ℕ) (x : ℕ) : ℕ := f (f x)

eval do_twice double 2    -- 8
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
These definitions are equivalent to the following:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">def double : ℕ → ℕ := λ x, x + x
def square : ℕ → ℕ := λ x, x * x
def do_twice : (ℕ → ℕ) → ℕ → ℕ := λ f x, f (f x)
</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>def double : ℕ → ℕ := λ x, x + x
def square : ℕ → ℕ := λ x, x * x
def do_twice : (ℕ → ℕ) → ℕ → ℕ := λ f x, f (f x)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can even use this approach to specify arguments that are types:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
g (f x)
</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
g (f x)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
As an exercise, we encourage you to use <code>do_twice</code> and <code>double</code> to
define functions that quadruple their input, and multiply the input
by 8. As a further exercise, we encourage you to try defining a
function
<code>Do_Twice : ((ℕ → ℕ) → (ℕ → ℕ)) → (ℕ → ℕ) → (ℕ → ℕ)</code>
which iterates <i>its</i> argument twice, so that <code>Do_Twice do_twice</code> a
function which iterates <i>its</i> input four times, and evaluate
<code>Do_Twice do_twice double 2</code>.
</p>

<p>
Above, we discussed the process of "currying" a function, that is,
taking a function <code>f (a, b)</code> that takes an ordered pair as an
argument, and recasting it as a function <code>f' a b</code> that takes two
arguments successively. As another exercise, we encourage you to
complete the following definitions, which "curry" and "uncurry" a
function.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-26' mode="ace/mode/lean" readonly="true">def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry

def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry
</juicy-ace-editor><div id='lean-full-code-26' style='display:none'>def curry (α β γ : Type) (f : α × β → γ) : α → β → γ := sorry

def uncurry (α β γ : Type) (f : α → β → γ) : α × β → γ := sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-26').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org5ef9064" class="outline-3">
<h3 id="org5ef9064"><span class="section-number-3"> 2.5</span> Local Definitions</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Lean also allows you to introduce "local" definitions using the <code>let</code>
construct. The expression <code>let a := t1 in t2</code> is definitionally equal to
the result of replacing every occurrence of <code>a</code> in <code>t2</code> by <code>t1</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-27' mode="ace/mode/lean" readonly="true">check let y := 2 + 2 in y * y   -- ℕ
eval  let y := 2 + 2 in y * y   -- 16

def t (x : ℕ) : ℕ :=
let y := x + x in y * y

eval t 2   -- 16
</juicy-ace-editor><div id='lean-full-code-27' style='display:none'>check let y := 2 + 2 in y * y   -- ℕ
eval  let y := 2 + 2 in y * y   -- 16

def t (x : ℕ) : ℕ :=
let y := x + x in y * y

eval t 2   -- 16
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-27').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Here, <code>t</code> is definitionally equal to the term <code>(x + x) * (x + x)</code>.
You can combine multiple assignments in a single <code>let</code> statement:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-28' mode="ace/mode/lean" readonly="true">check let y := 2 + 2, z := y + y in z * z   -- 16
eval  let y := 2 + 2, z := y + y in z * z   -- 64
</juicy-ace-editor><div id='lean-full-code-28' style='display:none'>check let y := 2 + 2, z := y + y in z * z   -- 16
eval  let y := 2 + 2, z := y + y in z * z   -- 64
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-28').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Notice that the meaning of the expression <code>let a := t1 in t2</code> is very
similar to the meaning of <code>(λ a, t2) t1</code>, but the two are not the
same. In the first expression, you should think of every instance of
<code>a</code> in <code>t2</code> as a syntactic abbreviation for <code>t1</code>. In the second
expression, <code>a</code> is a variable, and the expression <code>λ a, t2</code> has to make
sense independently of the value of <code>a</code>. The <code>let</code> construct is a
stronger means of abbreviation, and there are expressions of the form
<code>let a := t1 in t2</code> that cannot be expressed as <code>(λ a, t2) t1</code>. As an
exercise, try to understand why the definition of <code>foo</code> below type
checks, but the definition of <code>bar</code> does not.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-29' mode="ace/mode/lean" readonly="true">def foo := let a := nat  in λ x : a, x + 2

/-
def bar := (λ a, λ x : a, x + 2) nat
-/
</juicy-ace-editor><div id='lean-full-code-29' style='display:none'>def foo := let a := nat  in λ x : a, x + 2

/-
def bar := (λ a, λ x : a, x + 2) nat
-/
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-29').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org6e8286d" class="outline-3">
<h3 id="Variables_and_Sections"><a id="org6e8286d"></a><span class="section-number-3"> 2.6</span> Variables and Sections</h3>
<div class="outline-text-3" id="text-Variables_and_Sections">
<p>
This is a good place to introduce some organizational features of Lean
that are not a part of the axiomatic framework <i>per se</i>, but make it
possible to work in the framework more efficiently.
</p>

<p>
We have seen that the <code>constant</code> command allows us to declare new
objects, which then become part of the global context. Declaring new
objects in this way is somewhat crass. Lean enables us to <i>define</i> all
of the mathematical objects we need, and <i>declaring</i> new objects
willy-nilly is therefore somewhat lazy. In the words of Bertrand
Russell, it has all the advantages of theft over honest toil. We will
see in the next chapter that it is also somewhat dangerous: declaring
a new constant is tantamount to declaring an axiomatic extension of
our foundational system, and may result in inconsistency.
</p>

<p>
So far, in this tutorial, we have used the <code>constant</code> command to
create "arbitrary" objects to work with in our examples. For example,
we have declared types <code>α</code>, <code>β</code>, and <code>γ</code> to populate our context. This
can be avoided, using implicit or explicit lambda abstraction in our
definitions to declare such objects "locally":
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-30' mode="ace/mode/lean" readonly="true">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) :
  γ := g (f x)

def do_twice (α : Type) (h : α → α) (x : α) : α := h (h x)

def do_thrice (α : Type) (h : α → α) (x : α) : α := h (h (h x))
</juicy-ace-editor><div id='lean-full-code-30' style='display:none'>def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) :
  γ := g (f x)

def do_twice (α : Type) (h : α → α) (x : α) : α := h (h x)

def do_thrice (α : Type) (h : α → α) (x : α) : α := h (h (h x))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-30').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Repeating declarations in this way can be tedious, however. Lean
provides us with the <code>variable</code> and <code>variables</code> commands to make such
declarations look global:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-31' mode="ace/mode/lean" readonly="true">variables (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ := g (f x)
def do_twice (h : α → α) (x : α) : α := h (h x)
def do_thrice (h : α → α) (x : α) : α := h (h (h x))
</juicy-ace-editor><div id='lean-full-code-31' style='display:none'>variables (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ := g (f x)
def do_twice (h : α → α) (x : α) : α := h (h x)
def do_thrice (h : α → α) (x : α) : α := h (h (h x))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-31').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can declare variables of any type, not just <code>Type</code> itself:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-32' mode="ace/mode/lean" readonly="true">variables (α β γ : Type)
variables (g : β → γ) (f : α → β) (h : α → α)
variable x : α

def compose := g (f x)
def do_twice := h (h x)
def do_thrice := h (h (h x))

print compose
print do_twice
print do_thrice
</juicy-ace-editor><div id='lean-full-code-32' style='display:none'>variables (α β γ : Type)
variables (g : β → γ) (f : α → β) (h : α → α)
variable x : α

def compose := g (f x)
def do_twice := h (h x)
def do_thrice := h (h (h x))

print compose
print do_twice
print do_thrice
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-32').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Printing them out shows that all three groups of definitions have
exactly the same effect.
</p>

<p>
The <code>variable</code> and <code>variables</code> commands look like the <code>constant</code> and
<code>constants</code> commands we have used above, but there is an important
difference: rather than creating permanent entities, the declarations
simply tell Lean to insert the variables as bound variables in
definitions that refer to them. Lean is smart enough to figure out
which variables are used explicitly or implicitly in a definition. We
can therefore proceed as though <code>α</code>, <code>β</code>, <code>γ</code>, <code>g</code>, <code>f</code>, <code>h</code>, and <code>x</code>
are fixed objects when we write our definitions, and let Lean abstract
the definitions for us automatically.
</p>

<p>
When declared in this way, a variable stays in scope until the end of
the file we are working on, and we cannot declare another variable
with the same name. Sometimes, however, it is useful to limit the
scope of a variable. For that purpose, Lean provides the notion of a
<code>section</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-33' mode="ace/mode/lean" readonly="true">section useful
  variables (α β γ : Type)
  variables (g : β → γ) (f : α → β) (h : α → α)
  variable x : α

  def compose := g (f x)
  def do_twice := h (h x)
  def do_thrice := h (h (h x))
end useful
</juicy-ace-editor><div id='lean-full-code-33' style='display:none'>section useful
  variables (α β γ : Type)
  variables (g : β → γ) (f : α → β) (h : α → α)
  variable x : α

  def compose := g (f x)
  def do_twice := h (h x)
  def do_thrice := h (h (h x))
end useful
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-33').text());">Try it yourself &raquo;</button></div>
</div>
<p>
When the section is closed, the variables go out of scope, and become
nothing more than a distant memory.
</p>

<p>
You do not have to indent the lines within a section, since Lean
treats any blocks of returns, spaces, and tabs equivalently as
whitespace. Nor do you have to name a section, which is to say, you
can use an anonymous <code>section</code> / <code>end</code> pair. If you do name a section,
however, you have to close it using the same name. Sections can also
be nested, which allows you to declare new variables incrementally.
</p>
</div>
</div>

<div id="outline-container-org37470dd" class="outline-3">
<h3 id="Namespaces"><a id="org37470dd"></a><span class="section-number-3"> 2.7</span> Namespaces</h3>
<div class="outline-text-3" id="text-Namespaces">
<p>
Lean provides us with the ability to group definitions, notation, and
other information into nested, hierarchical <i>namespaces</i>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-34' mode="ace/mode/lean" readonly="true">namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a
  def ffa : ℕ := f (f a)

  print "inside foo"

  check a
  check f
  check fa
  check ffa
  check foo.fa
end foo

print "outside the namespace"

-- check a  -- error
-- check f  -- error
check foo.a
check foo.f
check foo.fa
check foo.ffa

open foo

print "opened foo"

check a
check f
check fa
check foo.fa
</juicy-ace-editor><div id='lean-full-code-34' style='display:none'>namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a
  def ffa : ℕ := f (f a)

  print "inside foo"

  check a
  check f
  check fa
  check ffa
  check foo.fa
end foo

print "outside the namespace"

-- check a  -- error
-- check f  -- error
check foo.a
check foo.f
check foo.fa
check foo.ffa

open foo

print "opened foo"

check a
check f
check fa
check foo.fa
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-34').text());">Try it yourself &raquo;</button></div>
</div>
<p>
When we declare that we are working in the namespace <code>foo</code>, every
identifier we declare has a full name with prefix "<code>foo.</code>" Within the
namespace, we can refer to identifiers by their shorter names, but
once we end the namespace, we have to use the longer names.
</p>

<p>
The <code>open</code> command brings the shorter names into the current
context. Often, when we import a theory file, we will want to open one or
more of the namespaces it contains, to have access to the short
identifiers, notations, and so on. But sometimes we will want to leave
this information hidden, for example, when they conflict with
identifiers and notations in another namespace we want to use. Thus
namespaces give us a way to manage our working environment.
</p>

<p>
For example, Lean groups definitions and theorems involving lists into
a namespace <code>list</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-35' mode="ace/mode/lean" readonly="true">check list.nil
check list.cons
check list.append
</juicy-ace-editor><div id='lean-full-code-35' style='display:none'>check list.nil
check list.cons
check list.append
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-35').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We will discuss their types, below. The command <code>open list</code> allows us
to use the shorter names:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-36' mode="ace/mode/lean" readonly="true">open list

check nil
check cons
check append
</juicy-ace-editor><div id='lean-full-code-36' style='display:none'>open list

check nil
check cons
check append
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-36').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Like sections, namespaces can be nested:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-37' mode="ace/mode/lean" readonly="true">namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a

  namespace bar
    def ffa : ℕ := f (f a)

    check fa
    check ffa
  end bar

  check fa
  check bar.ffa
end foo

check foo.fa
check foo.bar.ffa

open foo

check fa
check bar.ffa
</juicy-ace-editor><div id='lean-full-code-37' style='display:none'>namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a

  namespace bar
    def ffa : ℕ := f (f a)

    check fa
    check ffa
  end bar

  check fa
  check bar.ffa
end foo

check foo.fa
check foo.bar.ffa

open foo

check fa
check bar.ffa
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-37').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Namespaces that have been closed can later be reopened, even in
another file:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-38' mode="ace/mode/lean" readonly="true">namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a
end foo

check foo.a
check foo.f

namespace foo
  def ffa : ℕ := f (f a)
end foo
</juicy-ace-editor><div id='lean-full-code-38' style='display:none'>namespace foo
  def a : ℕ := 5
  def f (x : ℕ) : ℕ := x + 7

  def fa : ℕ := f a
end foo

check foo.a
check foo.f

namespace foo
  def ffa : ℕ := f (f a)
end foo
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-38').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Like sections, nested namespaces have to be closed in the order they
are opened. Also, a namespace cannot be opened within a section;
namespaces have to live on the outer levels.
</p>

<p>
Namespaces and sections serve different purposes: namespaces organize
data and sections declare variables for insertion in theorems. A
namespace can be viewed as a special kind of section, however. In
particular, if you use the <code>variable</code> command within a namespace, its
scope is limited to the namespace. Similarly, if you use an <code>open</code>
command within a namespace, its effects disappear when the namespace
is closed.
</p>

<p>
As scoping mechanisms, namespaces and sections govern more than just
variables and identifier names. We will later see that notations
defined in a namespace are operant only when the namespace is open,
and notation defined in a section has scope limited to the
section. Similarly, if we use the <code>open</code> command inside a section or
namespace, it only remains in effect until that section or namespace
is closed. As a result, namespaces and sections provide useful ways of
managing the background context while we work with Lean.
</p>
</div>
</div>

<div id="outline-container-org105dcd4" class="outline-3">
<h3 id="Dependent_Types"><a id="org105dcd4"></a><span class="section-number-3"> 2.8</span> Dependent Types</h3>
<div class="outline-text-3" id="text-Dependent_Types">
<p>
You now have rudimentary ways of defining functions and objects in Lean,
and we will gradually introduce you to many more. Our ultimate goal in
Lean is to <i>prove</i> things about the objects we define, and the next
chapter will introduce you to Lean's mechanisms for stating theorems
and constructing proofs. Meanwhile, let us remain on the topic of
defining objects in dependent type theory for just a moment longer,
in order to explain what makes dependent type theory <i>dependent</i>, and
why that is useful.
</p>

<p>
The short explanation is that what makes dependent type theory
dependent is that types can depend on parameters. You have already
seen a nice example of this: the type <code>list α</code> depends on the argument
<code>α</code>, and this dependence is what distinguishes <code>list ℕ</code> and <code>list
bool</code>. For another example, consider the type <code>vec α n</code>, the type of
vectors of elements of <code>α</code> of length <code>n</code>. This type depends on <i>two</i>
parameters: the type <code>α : Type</code> of the elements in the vector and the
length <code>n : ℕ</code>.
</p>

<p>
Suppose we wish to write a function <code>cons</code> which inserts a new element
at the head of a list. What type should <code>cons</code> have? Such a function
is <i>polymorphic</i>: we expect the <code>cons</code> function for <code>ℕ</code>, <code>bool</code>, or
an arbitrary type <code>α</code> to behave the same way. So it makes sense to
take the type to be the first argument to <code>cons</code>, so that for any
type, <code>α</code>, <code>cons α</code> is the insertion function for lists of type
<code>α</code>. In other words, for every <code>α</code>, <code>cons α</code> is the function that
takes an element <code>a : α</code> and a list <code>l : list α</code>, and returns a new
list, so we have <code>cons α a l : list α</code>.
</p>

<p>
It is clear that <code>cons α</code> should have type <code>α → list α → list α</code>. But
what type should <code>cons</code> have? A first guess might be <code>Type → α → list
α → list α</code>, but, on reflection, this does not make sense: the <code>α</code> in
this expression does not refer to anything, whereas it should refer to
the argument of type <code>Type</code>. In other words, <i>assuming</i> <code>α : Type</code> is
the first argument to the function, the type of the next two elements
are <code>α</code> and <code>list α</code>. These types vary depending on the first
argument, <code>α</code>.
</p>

<p>
This is an instance of a <i>Pi type</i> in dependent type theory. Given
<code>α : Type</code> and <code>β : α → Type</code>, think of <code>β</code> as a family of types over
<code>α</code>, that is, a type <code>β a</code> for each <code>a : α</code>. In that case, the type
<code>Π x : α, β x</code> denotes the type of functions <code>f</code> with the property
that, for each <code>a : α</code>, <code>f a</code> is an element of <code>β a</code>. In other words,
the type of the value returned by <code>f</code> depends on its input.
</p>

<p>
Notice that <code>Π x : α, β</code> makes sense for any expression <code>β :
Type</code>. When the value of <code>β</code> depends on <code>x</code> (as does, for example, the
expression <code>β x</code> in the previous paragraph), <code>Π x : α, β</code> denotes a
dependent function type. When <code>β</code> doesn't depend on <code>x</code>, <code>Π
x : α, β</code> is no different from the type <code>α → β</code>. Indeed, in dependent
type theory (and in Lean), the Pi construction is fundamental, and <code>α
→ β</code> is nothing more than notation for <code>Π x : α, β</code> when <code>β</code> does not
depend on <code>α</code>.
</p>

<p>
Returning to the example of lists, we can model some basic list
operations as follows. We use <code>namespace hide</code> to avoid a naming conflict
with the <code>list</code> type defined in the standard library.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-39' mode="ace/mode/lean" readonly="true">namespace hide

universe variable u

constant list : Type u → Type u

constant cons : Π α : Type u, α → list α → list α
constant nil : Π α : Type u, list α
constant head : Π α : Type u, list α → α
constant tail : Π α : Type u, list α → list α
constant append : Π α : Type u, list α → list α → list α

end hide
</juicy-ace-editor><div id='lean-full-code-39' style='display:none'>namespace hide

universe variable u

constant list : Type u → Type u

constant cons : Π α : Type u, α → list α → list α
constant nil : Π α : Type u, list α
constant head : Π α : Type u, list α → α
constant tail : Π α : Type u, list α → list α
constant append : Π α : Type u, list α → list α → list α

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-39').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can enter the symbol <code>Π</code> by typing <code>\Pi</code>. Here, <code>nil</code> is intended
to denote the empty list, <code>head</code> and <code>tail</code> return the first element
of a list and the remainder, respectively. The constant <code>append</code> is
intended to denote the function that concatenates two lists.
</p>

<p>
We emphasize that these constant declarations are only for the
purposes of illustration. The <code>list</code> type and all these operations
are, in fact, <i>defined</i> in Lean's standard library, and are proved to
have the expected properties. In fact, as the next example shows, the
types indicated above are essentially the types of the objects that
are defined in the library. (We will explain the <code>@</code> symbol and the
difference between the round and curly brackets momentarily.)
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-40' mode="ace/mode/lean" readonly="true">open list

check list     -- Type u_1 → Type u_1

check @cons    -- Π {α : Type u_1}, α → list α → list α
check @nil     -- Π {α : Type u_1}, list α
check @head    -- Π {α : Type u_1} [_inst_1 : inhabited α], list α → α
check @tail    -- Π {α : Type u_1}, list α → list α
check @append  -- Π {α : Type u_1}, list α → list α → list α
</juicy-ace-editor><div id='lean-full-code-40' style='display:none'>open list

check list     -- Type u_1 → Type u_1

check @cons    -- Π {α : Type u_1}, α → list α → list α
check @nil     -- Π {α : Type u_1}, list α
check @head    -- Π {α : Type u_1} [_inst_1 : inhabited α], list α → α
check @tail    -- Π {α : Type u_1}, list α → list α
check @append  -- Π {α : Type u_1}, list α → list α → list α
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-40').text());">Try it yourself &raquo;</button></div>
</div>
<p>
There is a subtlety in the definition of <code>head</code>: the type <code>α</code> is
required to have at least one element, and when passed the
empty list, the function must determine a default element of the
relevant type. We will explain how this is done in a later chapter.
</p>

<p>
Vector operations are handled similarly:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-41' mode="ace/mode/lean" readonly="true">universe variable u
constant vec : Type u → ℕ → Type u

namespace vec
  constant empty : Π α : Type u, vec α 0
  constant cons :
    Π (α : Type u) (n : ℕ), α → vec α n → vec α (n + 1)
  constant append :
    Π (α : Type u) (n m : ℕ),  vec α m → vec α n → vec α (n + m)
end vec
</juicy-ace-editor><div id='lean-full-code-41' style='display:none'>universe variable u
constant vec : Type u → ℕ → Type u

namespace vec
  constant empty : Π α : Type u, vec α 0
  constant cons :
    Π (α : Type u) (n : ℕ), α → vec α n → vec α (n + 1)
  constant append :
    Π (α : Type u) (n m : ℕ),  vec α m → vec α n → vec α (n + m)
end vec
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-41').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In the coming chapters, you will come across many instances of
dependent types. Here we will mention just one more important and
illustrative example, the <i>Sigma types</i>, <code>Σ x : α, β x</code>, sometimes
also known as <i>dependent pairs</i>. These are, in a sense, companions to
the Pi types. The type <code>Σ x : α, β x</code> denotes the type of pairs
<code>sigma.mk a b</code> where <code>a : α</code> and <code>b : β a</code>.
</p>

<p>
Just as Pi types <code>Π x : α, β x</code> generalize the notion of a function
type <code>α → β</code> by allowing <code>β</code> to depend on <code>α</code>, Sigma types <code>Σ x : α, β
x</code> generalize the cartesian product <code>α × β</code> in the same way: in the
expression <code>sigma.mk a b</code>, the type of the second element of the pair,
<code>b : β a</code>, depends on the first element of the pair, <code>a : α</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-42' mode="ace/mode/lean" readonly="true">variable α : Type
variable β : α → Type
variable a : α
variable b : β a

check sigma.mk a b   -- Σ (a : α), β a
check (sigma.mk a b).1  -- α
check (sigma.mk a b).2  -- β (sigma.fst (sigma.mk a b))

eval  (sigma.mk a b).1  -- a
eval  (sigma.mk a b).2  -- b
</juicy-ace-editor><div id='lean-full-code-42' style='display:none'>variable α : Type
variable β : α → Type
variable a : α
variable b : β a

check sigma.mk a b   -- Σ (a : α), β a
check (sigma.mk a b).1  -- α
check (sigma.mk a b).2  -- β (sigma.fst (sigma.mk a b))

eval  (sigma.mk a b).1  -- a
eval  (sigma.mk a b).2  -- b
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-42').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that when <code>p</code> is a dependent pair the expressions <code>(sigma.mk a b).1</code> and
<code>(sigma.mk a b).2</code> are short for <code>sigma.fst (sigma.mk a b)</code> and <code>sigma.snd
(sigma.mk a b)</code>, respectively, and that these reduce to <code>a</code> and <code>b</code>,
respectively.
</p>
</div>
</div>

<div id="outline-container-orgc454de0" class="outline-3">
<h3 id="Implicit_Arguments"><a id="orgc454de0"></a><span class="section-number-3"> 2.9</span> Implicit Arguments</h3>
<div class="outline-text-3" id="text-Implicit_Arguments">
<p>
Suppose we have an implementation of lists as described above.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-43' mode="ace/mode/lean" readonly="true">namespace hide
universe variable u
constant list : Type u → Type u

namespace list
  constant cons : Π α : Type u, α → list α → list α
  constant nil : Π α : Type u, list α
  constant append : Π α : Type u, list α → list α → list α
end list
end hide
</juicy-ace-editor><div id='lean-full-code-43' style='display:none'>namespace hide
universe variable u
constant list : Type u → Type u

namespace list
  constant cons : Π α : Type u, α → list α → list α
  constant nil : Π α : Type u, list α
  constant append : Π α : Type u, list α → list α → list α
end list
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-43').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Then, given a type <code>α</code>, some elements of <code>α</code>, and some lists of
elements of <code>α</code>, we can construct new lists using the constructors.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-44' mode="ace/mode/lean" readonly="true">open hide.list

variable  α : Type
variable  a : α
variables l1 l2 : list α

check cons α a (nil α)
check append α (cons α a (nil α)) l1
check append α (append α (cons α a (nil α)) l1) l2</juicy-ace-editor><div id='lean-full-code-44' style='display:none'>namespace hide
universe variable u
constant list : Type u → Type u

namespace list
  constant cons : Π α : Type u, α → list α → list α
  constant nil : Π α : Type u, list α
  constant append : Π α : Type u, list α → list α → list α
end list

open hide.list

variable  α : Type
variable  a : α
variables l1 l2 : list α

check cons α a (nil α)
check append α (cons α a (nil α)) l1
check append α (append α (cons α a (nil α)) l1) l2
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-44').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Because the constructors are polymorphic over types, we have to insert
the type <code>α</code> as an argument repeatedly. But this information is
redundant: one can infer the argument <code>α</code> in <code>cons α a (nil α)</code> from
the fact that the second argument, <code>a</code>, has type <code>α</code>. One can
similarly infer the argument in <code>nil α</code>, not from anything else in
that expression, but from the fact that it is sent as an argument to
the function <code>cons</code>, which expects an element of type <code>list α</code> in that
position.
</p>

<p>
This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context. In Lean, one uses an underscore, <code>_</code>, to specify
that the system should fill in the information automatically. This is
known as an "implicit argument."
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-45' mode="ace/mode/lean" readonly="true">check cons _ a (nil _)
check append _ (cons _ a (nil _)) l1
check append _ (append _ (cons _ a (nil _)) l1) l2</juicy-ace-editor><div id='lean-full-code-45' style='display:none'>namespace hide
universe variable u
constant list : Type u → Type u

namespace list
  constant cons : Π α : Type u, α → list α → list α
  constant nil : Π α : Type u, list α
  constant append : Π α : Type u, list α → list α → list α
end list

open hide.list

variable  α : Type
variable  a : α
variables l1 l2 : list α

check cons _ a (nil _)
check append _ (cons _ a (nil _)) l1
check append _ (append _ (cons _ a (nil _)) l1) l2
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-45').text());">Try it yourself &raquo;</button></div>
</div>

<p>
It is still tedious, however, to type all these underscores.  When a
function takes an argument that can generally be inferred from
context, Lean allows us to specify that this argument should, by
default, be left implicit. This is done by putting the arguments in
curly braces, as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-46' mode="ace/mode/lean" readonly="true">namespace list
  constant cons : Π {α : Type u}, α → list α → list α
  constant nil : Π {α : Type u}, list α
  constant append : Π {α : Type u}, list α → list α → list α
end list

open hide.list

variable  α : Type
variable  a : α
variables l1 l2 : list α

check cons a nil
check append (cons a nil) l1
check append (append (cons a nil) l1) l2</juicy-ace-editor><div id='lean-full-code-46' style='display:none'>namespace hide
universe variable u
constant list : Type u → Type u

namespace list
  constant cons : Π {α : Type u}, α → list α → list α
  constant nil : Π {α : Type u}, list α
  constant append : Π {α : Type u}, list α → list α → list α
end list

open hide.list

variable  α : Type
variable  a : α
variables l1 l2 : list α

check cons a nil
check append (cons a nil) l1
check append (append (cons a nil) l1) l2
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-46').text());">Try it yourself &raquo;</button></div>
</div>
<p>
All that has changed are the braces around <code>α : Type u</code> in the
declaration of the variables. We can also use this device in function
definitions:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-47' mode="ace/mode/lean" readonly="true">universe variable u
def ident {α : Type u} (x : α) := x

variables α β : Type u
variables (a : α) (b : β)

check ident      -- ?M_1 → ?M_1
check ident a    -- α
check ident b    -- β
</juicy-ace-editor><div id='lean-full-code-47' style='display:none'>universe variable u
def ident {α : Type u} (x : α) := x

variables α β : Type u
variables (a : α) (b : β)

check ident      -- ?M_1 → ?M_1
check ident a    -- α
check ident b    -- β
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-47').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This makes the first argument to <code>ident</code> implicit. Notationally, this
hides the specification of the type, making it look as though <code>ident</code>
simply takes an argument of any type. In fact, the function <code>id</code> is
defined in the standard library in exactly this way. We have chosen
a nontraditional name here only to avoid a clash of names.
</p>

<p>
Variables can also be declared implicit when they are declared with
the <code>variables</code> command:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-48' mode="ace/mode/lean" readonly="true">universe variable u

section
  variable {α : Type u}
  variable x : α
  def ident := x
end

variables α β : Type u
variables (a : α) (b : β)

check ident
check ident a
check ident b
</juicy-ace-editor><div id='lean-full-code-48' style='display:none'>universe variable u

section
  variable {α : Type u}
  variable x : α
  def ident := x
end

variables α β : Type u
variables (a : α) (b : β)

check ident
check ident a
check ident b
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-48').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This definition of <code>ident</code> has the same effect as the one above.
</p>

<p>
Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs. The process of instantiating these
"holes," or "placeholders," in a term is often known as
<i>elaboration</i>. The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely. An expression like <code>id</code> or <code>list.nil</code> is said to
be <i>polymorphic</i>, because it can take on different meanings in
different contexts. One can always specify the type <code>T</code> of an
expression <code>e</code> by writing <code>(e : T)</code>. This instructs Lean's elaborator
to use the value <code>T</code> as the type of <code>e</code> when trying to resolve
implicit arguments. The second pair of examples below use this
mechanism to specify the desired types of the expressions <code>id</code> and
<code>list.nil</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-49' mode="ace/mode/lean" readonly="true">check list.nil             -- list ?M1
check id                   -- ?M1 → ?M1

check (list.nil : list ℕ)  -- list ℕ
check (id : ℕ → ℕ)         -- ℕ → ℕ
</juicy-ace-editor><div id='lean-full-code-49' style='display:none'>check list.nil             -- list ?M1
check id                   -- ?M1 → ?M1

check (list.nil : list ℕ)  -- list ℕ
check (id : ℕ → ℕ)         -- ℕ → ℕ
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-49').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number. So
the expressions in the first two <code>check</code> commands are elaborated in
the same way, whereas the third <code>check</code> command interprets <code>2</code> as a
raw numeral.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-50' mode="ace/mode/lean" readonly="true">check 2            -- ℕ
check (2 : ℕ)      -- ℕ
check (2 : num)    -- num
</juicy-ace-editor><div id='lean-full-code-50' style='display:none'>check 2            -- ℕ
check (2 : ℕ)      -- ℕ
check (2 : num)    -- num
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-50').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly. If <code>foo</code> is such a function, the
notation <code>@foo</code> denotes the same function with all the arguments made
explicit.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-51' mode="ace/mode/lean" readonly="true">check @id        -- Π {α : Type u_1}, α → α
check @id α      -- α → α
check @id β      -- β → β
check @id α a    -- α
check @id β b    -- β</juicy-ace-editor><div id='lean-full-code-51' style='display:none'>variables α β : Type
variables (a : α) (b : β)

check @id        -- Π {α : Type u_1}, α → α
check @id α      -- α → α
check @id β      -- β → β
check @id α a    -- α
check @id β b    -- β
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-51').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that now the first <code>check</code> command gives the type of the
identifier, <code>id</code>, without inserting any placeholders. Moreover, the
output indicates that the first argument is implicit.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
